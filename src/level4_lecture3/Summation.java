package level4_lecture3;

import java.util.Scanner;

/*
Напишем программу, в которой нужно вводить с клавиатуры целые числа и считать их сумму, пока пользователь не введет
слово "ENTER". Вывести на экран полученную сумму и завершить программу.

        Требования:
        •	Программа должна считывать данные c клавиатуры.
        •	Необходимо посчитать сумму введенных целых чисел и вывести её на экран, если пользователь ввел стоп слово.
        •	В программе необходимо использовать цикл while.
 */

public class Summation {
    public static void main(String[] args) {
        //yourSolution();
        cleanCodeSolution();
    }

    public static void yourSolution() {
        Scanner scanner = new Scanner(System.in);
        String input;
        int sum = 0;
        while (!(input = scanner.nextLine()).equals("ENTER")) {
            sum += Integer.parseInt(input);
            }
        {
            System.out.print(sum);
        }

    }

    public static void cleanCodeSolution() {
        Scanner scanner = new Scanner(System.in);
        int sum = 0;
        String line = "";
        do {
            if (scanner.hasNextInt()){
                sum += scanner.nextInt();
            } else {
                line = scanner.nextLine();
            }
        } while (!line.equals("ENTER"));
        System.out.println(sum);
    }
}

/*
    EXPLANATION:
    Сразу хочу отметить, что все решено верно и в соответствии с требованиями - Необходимо использовать цикл while.
    Почему лучше использовать do while:
     первое это парсинг на 26 строке (ПОПЫТКА преобразования строки в число). Если есть возможность не использовать
     парсинг лучше его не использовать. Нет, это не значит, что нужно избегать использования парсинга, но если есть
     возможность решить по другому без сильного усложнения кода, то лучще не использовать. Дело в том, что если
     мы в строке, которую мы преобразовываем окажется не цифра, а например буква - парсинг закончится ошибкой и
     программа остановится(сломается). В твоем решении как раз есть такая ситуация: предположим мы ввели в консоль
     букву "w", далее в строке 25 while проверит, что "w" не равно "ENTER" и продолжит работу внутри фигурных скобок,
     а на строке 26 Integer.parseInt(input) попытается преобразовать "w" в цифру и преобразование закончится ошибкой.
     Да, используя простой while, не получится избежать Integer.parseInt(input).
     В случае с do while мы имеем возможность сначала считать строку и проанализировать что в этой строке будет и
     только потом проверить условие не был ли введен "ENTER" и таким образом избежать парсинга. Да, в условиях этого
     нету и валидатор принимает решение, но лучше всегда обдумывать и экпериментировать, что может сломать написанный
     код - это очень полезная практика.

    Также хочу добавить про while(true), т.к. такого надо однозначно избегать (была похожая задача на break), т.к. он
    намекает на бесконечный цикл, что недопустимо. Бывают космически редкие случаи, когда условие выхода из while,
    которое должны были быть в круглых скобках while вместо true, формируется где-то в середине кода в фигурных скобах,
    этого же while - тогда без while(true) никак не обойтись, к сожалению. Но чаще while(true) можно избежать.
    Схематичный пример как заменить while(true) на do while:

     while (true) {
        %какой-то код%
        if (%какое-то условие чтобы выйти из цикла%) {
            break;
        }
     }

     ===========

     do {
        %какой-то код%
     } while (%какое-то условие чтобы выйти из цикла%);

    *К слову, если немного путает break (или continue) заключенный в if как в строках 74-76, то хочу напомнить, что if
    просто выполняет или не выполняет код в своих фигурных скобках, в зависимости от условия (true/false). Ни break, ни
    continue никак не влияют, ни на if, ни на if else. Break и continue влияют только на итеративные конструкции
    (которые что-то перебирают, мы с такими уже знакомы - for и while) внутри которых находятся. Т.е в данном
    случае(74-76), мы if'ом решаем сделать break или нет.
 */
